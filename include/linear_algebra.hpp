#pragma once
//--------------------------------------------------------------------------
#include <iostream>
#include <cmath>
//--------------------------------------------------------------------------
class Point // (x, y, z)
{ 
    private:
    double x_ = NAN;
    double y_ = NAN;
    double z_ = NAN; 

    public:
    Point(double x, double y, double z) : x_(x), y_(y), z_(z){}

    bool point_is_valid()
    {
        if((x_ != NAN) && (y_ != NAN) && (z_ != NAN))
        {
            return true;
        }

        return false;
    }

    double getX()
    {
        return x_;
    }

    double getY()
    {
        return y_;
    }

    double getZ()
    {
        return z_;
    }
};// добавить нумерацию вершин?
//--------------------------------------------------------------------------
class Line // (x - x1)/x_direction = (y - y1)/y_direction = (z - z1)/z_direction
{// кажется надо изменить уравнение, direction? L(t) = P + td
    private:
    double x_direction;
    double y_direction;
    double z_direction;


    public:
    Line(Point &p1, Point &p2)
    {
        x_direction = p2.getX() - p1.getX(); 
        y_direction = p2.getY() - p1.getY();
        z_direction = p2.getZ() - p1.getZ();
    }
};
//--------------------------------------------------------------------------
// a * (x – x0) + b * (y – y0) + c * (z – z0) = 0, где a, b, c - отношения направлений нормали к плоскости,
// а (x0, y0, z0) - координаты любой точки, принадлежащей плоскости
class Plane 
{
    private:
        
    public:
    // построить плоскость по треугольнику по 3 точкам
    
    // найти уравнение прямой L пересечения
    // проверка на параллельность
    // нормали?
    
    // расстояние от плоскости до точки

};
//--------------------------------------------------------------------------
class Vector
{

};
//--------------------------------------------------------------------------
// triangle-triangle intersection - p.576-578
// plane-plane intersection - p.565

// Алгоритм
// 1. Проверяем что Т0 и Т1 валидны (треугольники), иначе -> выход == проверка следующей пары треугольников
// 2. Получить уравнение P0 == плоскости, где лежит треугольник Т0
// 3. Посчитать знаковое расстояние от 
// 4. ?
// 5. Посчитать уравнение P1 - плоскости треугольник Т1
// 6. Если уравнения P0 = P1, проверить совпадают ли плоскости
//    Если совпадают -> проверка на 2D пересечение треугольников
//    Не совпадают -> параллельны - exit
// 7. ?
// 8. Линия пересечения - получить уравнение
// 9. Интервалы по которым понять есть ли пересечение

